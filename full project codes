#pubspec.yaml
dependencies:
  flutter:
    sdk: flutter

  # Firebase
  firebase_core: ^4.1.0
  firebase_auth: ^6.0.2
  cloud_firestore: ^6.0.1
  google_sign_in: ^7.1.1
  # Location Services
  geolocator: ^14.0.2
  google_maps_flutter: ^2.5.3
  collection: ^1.18.0
  # State Management & Utilities
  get: ^4.6.6
  permission_handler: ^12.0.1
  intl: ^0.20.2
  cupertino_icons: ^1.0.8
  geocoding: ^4.0.0
  flutter_svg: ^2.2.0
  firebase_messaging: ^16.0.1
  background_fetch: ^1.4.0
  location: ^8.0.1
  get_storage: ^2.1.1

// lib/main.dart
import 'package:background_fetch/background_fetch.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:location/location.dart';
import 'app/routes/app_pages.dart';
import 'app/theme/app_theme.dart';
import 'firebase_options.dart';

// --- THIS IS THE BACKGROUND TASK HANDLER --- 4
// This function will be called by the OS when it's time to run our background task.
@pragma('vm:entry-point')
void backgroundFetchHeadlessTask(HeadlessTask task) async {
  String taskId = task.taskId;
  bool isTimeout = task.timeout;

  if (isTimeout) {
    print("[BackgroundFetch] Headless task timed-out: $taskId");
    BackgroundFetch.finish(taskId);
    return;
  }
  print("[BackgroundFetch] Headless event received: $taskId");

  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);

  final user = FirebaseAuth.instance.currentUser;
  if (user != null) {
    final userDoc = await FirebaseFirestore.instance.collection('users').doc(user.uid).get();

    if (userDoc.exists && userDoc.data()?['isCheckedIn'] == true) {
      print("[BackgroundFetch] User is checked in. Getting location...");

      Location location = Location();
      try {
        LocationData locationData = await location.getLocation().timeout(const Duration(seconds: 30)); // You might want to increase this timeout too

        // --- ADD THIS CHECK ---
        if (locationData.isMock == true) {
          print("[BackgroundFetch] Mock location detected. Skipping update.");
          BackgroundFetch.finish(taskId); // Finish task, but do not update location
          return;
        }
        // --- END OF ADDED CHECK ---

        await FirebaseFirestore.instance.collection('users').doc(user.uid).update({
          'currentLocation': GeoPoint(locationData.latitude!, locationData.longitude!),
          'lastSeen': FieldValue.serverTimestamp(),
        });
        print("[BackgroundFetch] Location updated successfully.");
      } catch (e) {
        print("[BackgroundFetch] Error getting or updating location: $e");
      }
    } else {
      print("[BackgroundFetch] User is not checked in. Skipping location update.");
    }
  } else {
    print("[BackgroundFetch] No user logged in. Stopping task.");
  }

  BackgroundFetch.finish(taskId);
}

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );
  runApp(const MyApp());

  // --- REGISTER THE BACKGROUND TASK HANDLER ---
  BackgroundFetch.registerHeadlessTask(backgroundFetchHeadlessTask);
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return GetMaterialApp(
      title: 'Joinery Worx',
      theme: AppTheme.lightTheme,
      themeMode: ThemeMode.system,
      initialRoute: AppPages.INITIAL,
      getPages: AppPages.routes,
      debugShowCheckedModeBanner: false,
    );
  }
}

// lib/app/models/activity_log_model.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:get/get.dart';

class ActivityLog {
  final String status;
  final Timestamp timestamp;
  final GeoPoint location;
  // Make the address an observable string so the UI can react when it's loaded.
  final RxString address = 'Loading address...'.obs;

  ActivityLog({
    required this.status,
    required this.timestamp,
    required this.location,
  });

  // A factory constructor to easily create an ActivityLog from a Firestore document
  factory ActivityLog.fromFirestore(DocumentSnapshot doc) {
    Map<String, dynamic> data = doc.data() as Map<String, dynamic>;
    return ActivityLog(
      status: data['status'] ?? 'unknown',
      timestamp: data['timestamp'] ?? Timestamp.now(),
      location: data['location'] ?? const GeoPoint(0, 0),
    );
  }
}

// lib/app/modules/auth/auth_binding.dart
import 'package:get/get.dart';
import 'auth_controller.dart';

class AuthBinding extends Bindings {
  @override
  void dependencies() {
    Get.lazyPut<AuthController>(
          () => AuthController(),
    );
  }
}

// lib/app/modules/auth/auth_controller.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';

class AuthController extends GetxController {
  final FirebaseAuth _auth = FirebaseAuth.instance;
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  // final FirebaseMessaging _firebaseMessaging = FirebaseMessaging.instance; // Ensure this is removed/commented

  final TextEditingController nameController = TextEditingController();
  final TextEditingController emailController = TextEditingController();
  final TextEditingController passwordController = TextEditingController();

  var isPasswordHidden = true.obs;
  var isLoading = false.obs;

  void togglePasswordVisibility() {
    isPasswordHidden.value = !isPasswordHidden.value;
  }

  Future<void> createUser() async {
    if (nameController.text.isEmpty ||
        emailController.text.isEmpty ||
        passwordController.text.isEmpty) {
      Get.snackbar('Error', 'All fields are required.');
      return;
    }
    isLoading.value = true;
    try {
      UserCredential userCredential =
      await _auth.createUserWithEmailAndPassword(
        email: emailController.text.trim(),
        password: passwordController.text.trim(),
      );

      await userCredential.user!.updateDisplayName(nameController.text.trim());

      // String? fcmToken = await _firebaseMessaging.getToken(); // Ensure this is removed/commented

      final newUser = {
        'uid': userCredential.user!.uid,
        'name': nameController.text.trim(),
        'email': emailController.text.trim(),
        'createdAt': FieldValue.serverTimestamp(),
        'lastSeen': FieldValue.serverTimestamp(),
        'accountEnabled': true,
        'role': 'staff',
        'position': '',
        'employeeId': '',
        'fcmToken': '', // Set to empty
        'isCheckedIn': false,
        'isClockedIn': false,
        'currentLocation': null,
      };

      await _firestore
          .collection('users')
          .doc(userCredential.user!.uid)
          .set(newUser);

      print(
          'User created: ${userCredential.user!.uid}, Name: ${nameController.text.trim()}');

      // Ensure this line IS REMOVED or commented out:
      // Get.offAllNamed(Routes.HOME);

    } on FirebaseAuthException catch (e) {
      Get.snackbar('Sign Up Failed', e.message ?? 'An unknown error occurred.');
    } finally {
      isLoading.value = false;
    }
  }

  Future<void> login() async {
    if (emailController.text.isEmpty || passwordController.text.isEmpty) {
      Get.snackbar('Error', 'Email and password are required.');
      return;
    }
    isLoading.value = true;
    try {
      await _auth.signInWithEmailAndPassword(
        email: emailController.text.trim(),
        password: passwordController.text.trim(),
      );

      // Ensure this line IS REMOVED or commented out:
      // Get.offAllNamed(Routes.HOME);

    } on FirebaseAuthException catch (e) {
      Get.snackbar('Login Failed', e.message ?? 'An unknown error occurred.');
    } finally {
      isLoading.value = false;
    }
  }
}

// lib/app/modules/auth/login_view.dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:get/get.dart';
import '../../theme/app_theme.dart';
import 'auth_controller.dart';

class LoginView extends GetView<AuthController> {
  // This RxBool allows switching between Login and Sign Up forms.
  final RxBool isLogin = true.obs;

  LoginView({super.key});

  @override
  Widget build(BuildContext context) {
    // Gets the screen size for responsive UI adjustments.
    final Size size = MediaQuery.of(context).size;

    return Scaffold(
      body: Stack(
        children: [
          // background header.
          Positioned(
            top: 0,
            left: 0,
            right: 0,
            child: Container(
              height: size.height * 0.55,
              decoration: const BoxDecoration(
                color: Color(0xFFEDE8D0),
                borderRadius: BorderRadius.only(
                  bottomLeft: Radius.circular(32),
                  bottomRight: Radius.circular(32),
                ),
              ),
            ),
          ),
          SafeArea(
            child: SingleChildScrollView(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  // App Icon Section
                  const SizedBox(height: 60),
                  // _buildAppIcon(),
                  Image.asset("assets/icons/O-logo.png", height: 120,),
                  const SizedBox(height: 25),
                  SvgPicture.asset(
                    'assets/icons-svg/text-logo.svg',
                    width: 256,
                    colorFilter: const ColorFilter.mode(
                      AppTheme.primaryDarkBlue,
                      BlendMode.srcIn,
                    ),
                  ),
                  const SizedBox(height: 25),
                  // This is the main white card for the login form.
                  Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 24.0),
                    child: Card(
                      elevation: 8,
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(24),
                      ),
                      child: Padding(
                        padding: const EdgeInsets.all(24.0),
                        // Obx makes the widget rebuild when isLogin changes.
                        child: Obx(
                              () => Column(
                            crossAxisAlignment: CrossAxisAlignment.stretch,
                            children: [
                              Text(
                                isLogin.value
                                    ? 'Welcome Back.'
                                    : 'Create Account.',
                                style: const TextStyle(
                                  fontSize: 24,
                                  fontWeight: FontWeight.bold,
                                  color: Color(0xFF1F2937),
                                ),
                              ),
                              const SizedBox(height: 4),
                              Text(
                                isLogin.value
                                    ? 'Sign in to continue tracking your activity.'
                                    : 'Sign up to get started today.',
                                style: const TextStyle(
                                  fontSize: 14,
                                  color: Color(0xFF6B7280),
                                ),
                              ),
                              const SizedBox(height: 24),

                              // Shows 'Full Name' field only on the Sign Up form.
                              if (!isLogin.value)
                                _buildTextField(
                                  hintText: 'Full Name',
                                  controller: controller.nameController,
                                  prefixIcon: Icons.person_outline,
                                ),
                              if (!isLogin.value) const SizedBox(height: 16),

                              // Email/Username field
                              _buildTextField(
                                hintText: 'Username or Email',
                                controller: controller.emailController,
                                prefixIcon: Icons.email_outlined,
                              ),
                              const SizedBox(height: 16),

                              // Password field with the visibility toggle
                              _buildPasswordTextField(),
                              const SizedBox(height: 24),

                              // Main Sign In or Sign Up button
                              ElevatedButton(
                                style: ElevatedButton.styleFrom(
                                  padding: const EdgeInsets.symmetric(
                                    vertical: 16,
                                  ),
                                  shape: RoundedRectangleBorder(
                                    borderRadius: BorderRadius.circular(12),
                                  ),
                                  elevation: 4,
                                  backgroundColor: AppTheme.primaryLightBlue,
                                ),
                                onPressed: () {
                                  // Calls the correct function from the controller
                                  if (isLogin.value) {
                                    controller.login();
                                  } else {
                                    controller.createUser();
                                  }
                                },
                                child: Text(
                                  isLogin.value ? 'Sign In' : 'Sign Up',
                                  style: const TextStyle(
                                    fontSize: 16,
                                    fontWeight: FontWeight.w600,

                                  ),
                                ),
                              ),
                              const SizedBox(height: 24),

                              // The button to switch between the two forms
                              Center(
                                child: TextButton(
                                  onPressed: () =>
                                  isLogin.value = !isLogin.value,
                                  child: Text(
                                    isLogin.value
                                        ? "Don't have an account? Sign Up"
                                        : "Already have an account? Sign In",
                                    style: const TextStyle(fontSize: 14),
                                  ),
                                ),
                              ),
                            ],
                          ),
                        ),
                      ),
                    ),
                  ),
                  const SizedBox(height: 30),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }

  // A helper widget to build the app icon and title.
  Widget _buildAppIcon() {
    return Column(
      children: [
        Container(
          width: 96,
          height: 96,
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(24),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.1),
                spreadRadius: 1,
                blurRadius: 10,
                offset: const Offset(0, 5),
              ),
            ],
          ),
          child: Center(
            child: Stack(
              alignment: Alignment.center,
              children: [
                Container(
                  width: 64,
                  height: 64,
                  decoration: BoxDecoration(
                    color: const Color(0xFF6A67F0),
                    borderRadius: BorderRadius.circular(32),
                  ),
                ),
                Positioned(
                  left: 0,
                  child: Container(
                    width: 32,
                    height: 64,
                    decoration: const BoxDecoration(
                      color: Color(0xFF3D3BB1),
                      borderRadius: BorderRadius.horizontal(
                        left: Radius.circular(32),
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
        const SizedBox(height: 16),
        const Text(
          'STAFF TRACKER',
          style: TextStyle(
            color: Colors.white,
            fontSize: 20,
            fontWeight: FontWeight.bold,
          ),
        ),
      ],
    );
  }

  // A reusable widget for standard text fields (like email and name).
  Widget _buildTextField({
    required String hintText,
    required TextEditingController controller,
    IconData? prefixIcon,
  }) {
    return TextFormField(
      controller: controller,
      decoration: InputDecoration(
        hintText: hintText,
        // The prefix icon you requested.
        prefixIcon: prefixIcon != null
            ? Icon(prefixIcon, color: const Color(0xFF9CA3AF))
            : null,
        hintStyle: const TextStyle(color: Color(0xFF9CA3AF)),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: Color(0xFFE5E7EB)),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: Color(0xFFE5E7EB)),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: Color(0xFF4F46E5), width: 2),
        ),
        contentPadding: const EdgeInsets.symmetric(
          horizontal: 16,
          vertical: 12,
        ),
      ),
    );
  }

  // A specific widget for the password field to handle the visibility toggle.
  Widget _buildPasswordTextField() {
    // Obx rebuilds this widget when controller.isPasswordHidden changes.
    return Obx(
          () => TextFormField(
        controller: controller.passwordController,
        obscureText: controller.isPasswordHidden.value,
        decoration: InputDecoration(
          hintText: 'Password',
          prefixIcon: const Icon(Icons.lock_outline, color: Color(0xFF9CA3AF)),
          hintStyle: const TextStyle(color: Color(0xFF9CA3AF)),
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(12),
            borderSide: const BorderSide(color: Color(0xFFE5E7EB)),
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(12),
            borderSide: const BorderSide(color: Color(0xFFE5E7EB)),
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(12),
            borderSide: const BorderSide(color: Color(0xFF4F46E5), width: 2),
          ),
          contentPadding: const EdgeInsets.symmetric(
            horizontal: 16,
            vertical: 12,
          ),
          // The clickable suffix icon for password visibility.
          suffixIcon: IconButton(
            icon: Icon(
              controller.isPasswordHidden.value
                  ? Icons.visibility_off_outlined
                  : Icons.visibility_outlined,
              color: const Color(0xFF9CA3AF),
            ),
            onPressed: controller.togglePasswordVisibility,
          ),
        ),
      ),
    );
  }
}

// lib/app/modules/home/home_binding.dart
import 'package:get/get.dart';
import '../auth/auth_controller.dart';
import 'home_controller.dart';

class HomeBinding extends Bindings {
  @override
  void dependencies() {
    // This line initializes the HomeController for the home screen.
    Get.lazyPut<HomeController>(() => HomeController());

    // --- ADD THIS LINE ---
    // This line ensures the AuthController is also available
    // so that we can call the signOut() method from it.
    Get.lazyPut<AuthController>(() => AuthController());
  }
}

// lib/app/modules/home/home_controller.dart
import 'dart:async';
import 'package:background_fetch/background_fetch.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:get_storage/get_storage.dart'; // Import GetStorage
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:location/location.dart';
import 'package:geocoding/geocoding.dart' as geocoding;
import 'package:intl/intl.dart';
import '../../models/activity_log_model.dart';
import '../../routes/app_pages.dart'; // Ensure Routes.LOGIN is accessible

class HomeController extends GetxController {
  final FirebaseAuth _auth = FirebaseAuth.instance;
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseMessaging _firebaseMessaging = FirebaseMessaging.instance;
  StreamSubscription? _activityStreamSubscription;
  StreamSubscription? _userDocSubscription;
  Timer? _timer;

  // --- GOOGLE MAPS ---
  GoogleMapController? mapController;
  var currentLatLng = Rx<LatLng?>(null);
  var markers = RxSet<Marker>();

  // --- OBSERVABLES ---
  var isClockedIn = false.obs;
  var userName = ''.obs;
  var isLoading = false.obs;
  var currentAddress = 'Getting location...'.obs;
  var lastActivityTime = 'N/A'.obs;
  var dateFilter = 'Last 7 Days'.obs;
  var activityLogs = <ActivityLog>[].obs;
  var isUserDataLoading = true.obs;
  var currentTime = ''.obs;
  var hasInitializedActivityListener = false;
  final GetStorage _deviceStorage = GetStorage(); // Added for single-device login
  var isLocationError = false.obs; // Added for button disabling

  @override
  void onInit() {
    super.onInit();
    _fetchUserData(); // Start listening to user data
    _getCurrentLocationAndAddress(); // Get initial location
    _setupFCM();
    _initBackgroundFetch();

    // --- Start live clock ---
    _updateTime();
    _timer = Timer.periodic(const Duration(seconds: 1), (_) => _updateTime());
  }

  @override
  void onClose() {
    _activityStreamSubscription?.cancel();
    _userDocSubscription?.cancel();
    mapController?.dispose();
    _timer?.cancel();
    super.onClose();
  }

  // --- Pull-to-refresh function ---
  Future<void> onPullToRefresh() async {
    print("Refreshing location and data...");
    // Re-fetch location which will update address and reset error state
    await _getCurrentLocationAndAddress();
    // _fetchUserData is likely already running via its listener,
    // but calling it again ensures we have the latest if the listener missed something.
    // However, avoid calling if already loading to prevent race conditions.
    if (!isUserDataLoading.value) {
      _fetchUserData(); // Re-sync user data from Firestore
    }
  }

  // --- Background Fetch setup ---
  Future<void> _initBackgroundFetch() async {
    int status = await BackgroundFetch.configure(
      BackgroundFetchConfig(
        minimumFetchInterval:
        5, // Android: ~5 mins, iOS: will default to ~15 mins
        stopOnTerminate: false, // Keep running after app termination (best effort)
        enableHeadless: true, // Enable headless task (requires separate setup)
        startOnBoot: true, // Start after device reboot
        requiredNetworkType: NetworkType.ANY, // Run even on cellular data
      ),
      _onBackgroundFetch, // Task when app is in foreground/background
      _onBackgroundFetchTimeout, // Task timeout handler
    );
    print('[BackgroundFetch] configure success: $status');

    // If the user is already checked in when the app starts, ensure tracking starts/resumes.
    if (isClockedIn.value) {
      _startTracking();
    }
  }

  // --- Background task logic ---
  void _onBackgroundFetch(String taskId) async {
    print("[BackgroundFetch] Event received: $taskId");
    final user = _auth.currentUser;
    // Check if user is logged in AND locally marked as clocked in
    if (user != null && isClockedIn.value) {
      print("[BackgroundFetch] User logged in and clocked in. Updating location.");
      try {
        LocationData? locationData = await _getCurrentLocation();
        if (locationData != null) {
          // Update user's last known location (for live view)
          await _firestore.collection('users').doc(user.uid).update({
            'currentLocation':
            GeoPoint(locationData.latitude!, locationData.longitude!),
            'lastSeen': FieldValue.serverTimestamp(),
          });

          // Add to historical location trail
          await _firestore
              .collection('users')
              .doc(user.uid)
              .collection('location_trail')
              .add({
            'timestamp': FieldValue.serverTimestamp(), // Secure server time
            'location':
            GeoPoint(locationData.latitude!, locationData.longitude!),
          });
          print("[BackgroundFetch] Location updated successfully.");
        } else {
          print("[BackgroundFetch] Failed to get location in background task.");
        }
      } catch (e) {
        print("[BackgroundFetch] Error during background location update: $e");
        // Consider logging this error more formally (e.g., to Crashlytics)
      }
    } else {
      print("[BackgroundFetch] User not logged in or not clocked in, skipping location update.");
    }
    // IMPORTANT: Tell the OS the task is finished.
    BackgroundFetch.finish(taskId);
  }

  // --- Background task timeout handler ---
  void _onBackgroundFetchTimeout(String taskId) {
    print("[BackgroundFetch] TIMEOUT: $taskId");
    BackgroundFetch.finish(taskId); // Must call finish even on timeout
  }

  // --- Helper methods to start/stop background tracking ---
  void _startTracking() {
    BackgroundFetch.start().then((int status) {
      print('[BackgroundFetch] start success: $status');
    }).catchError((e) {
      print('[BackgroundFetch] start FAILURE: $e');
    });
  }

  void _stopTracking() {
    BackgroundFetch.stop().then((int status) {
      print('[BackgroundFetch] stop success: $status');
    });
  }

  // --- FCM Setup ---
  Future<void> _setupFCM() async {
    NotificationSettings settings = await _firebaseMessaging.requestPermission(
      alert: true,
      announcement: false,
      badge: true,
      carPlay: false,
      criticalAlert: false,
      provisional: false,
      sound: true,
    );
    print('User granted notification permission: ${settings.authorizationStatus}');

    if (settings.authorizationStatus == AuthorizationStatus.authorized) {
      try {
        String? token = await _firebaseMessaging.getToken();
        print('FCM Token: $token');
        // Save token to Firestore AND local storage
        await _saveTokenToFirestore(token);
        // Listen for token refreshes
        _firebaseMessaging.onTokenRefresh.listen(_saveTokenToFirestore);
      } catch (e) {
        print('Error getting/saving FCM token: $e');
      }
    } else {
      print('User declined or has not accepted notification permissions');
    }
  }

  // --- Save FCM Token (including local save for single-device login) ---
  Future<void> _saveTokenToFirestore(String? token) async {
    if (token == null || token.isEmpty) {
      print('Attempted to save null or empty token.');
      return;
    }
    final user = _auth.currentUser;
    if (user == null) {
      print('User not logged in, cannot save token yet.');
      return;
    }
    try {
      // Save token locally for comparison
      await _deviceStorage.write('fcmToken', token);
      print('FCM Token saved locally.');

      // Check if Firestore already has the same token
      final userDoc = await _firestore.collection('users').doc(user.uid).get();
      if (userDoc.exists && userDoc.data()?['fcmToken'] == token) {
        print('FCM Token is already up-to-date in Firestore.');
        return;
      }

      // Update Firestore (this triggers check on other devices)
      await _firestore
          .collection('users')
          .doc(user.uid)
          .set({'fcmToken': token}, SetOptions(merge: true));
      print('FCM Token saved/updated in Firestore.');
    } catch (e) {
      print('Error saving FCM token to Firestore: $e');
    }
  }

  // --- Update live clock time ---
  void _updateTime() {
    final String formattedTime =
    DateFormat('EEE, MMM d | hh:mm:ss a').format(DateTime.now());
    currentTime.value = formattedTime;
  }

  // --- Google Map Initialization ---
  void onMapCreated(GoogleMapController controller) {
    mapController = controller;
    // Update map location if LatLng is already available
    if (currentLatLng.value != null) {
      _updateMapLocation();
    }
  }

  // --- Update Map View (with null checks) ---
  void _updateMapLocation() {
    if (mapController != null && currentLatLng.value != null) {
      markers.value = {
        Marker(
          markerId: const MarkerId('currentLocation'),
          position: currentLatLng.value!,
          infoWindow: const InfoWindow(title: 'Your Location'),
        ),
      };
      try {
        mapController!.animateCamera(
          CameraUpdate.newCameraPosition(
            CameraPosition(
              target: currentLatLng.value!,
              zoom: 16.0,
            ),
          ),
        );
      } catch (e) {
        print("Error animating map camera in _updateMapLocation: $e");
      }
    } else {
      print(
          "Map controller not ready or location not available for map update.");
    }
  }

  // --- Fetch User Data (with single-device login check) ---
  void _fetchUserData() {
    isUserDataLoading.value = true;
    final user = _auth.currentUser;
    if (user != null) {
      // Set initial name guess while loading
      userName.value = user.displayName ?? user.email ?? 'Staff Member';

      // Cancel previous listener if exists
      _userDocSubscription?.cancel();

      _userDocSubscription = _firestore
          .collection('users')
          .doc(user.uid)
          .snapshots()
          .listen((doc) async { // Make listener async for await
        if (doc.exists && doc.data() != null) {
          final data = doc.data()!;

          // --- Single-Device Login Security Check ---
          final String? localToken = _deviceStorage.read('fcmToken');
          final String? cloudToken = data['fcmToken'];

          if (localToken != null &&
              cloudToken != null &&
              localToken.isNotEmpty &&
              cloudToken.isNotEmpty &&
              localToken != cloudToken) {

            print('Newer login detected on another device. Signing out this device.');
            // Cancel this listener before doing anything else
            _userDocSubscription?.cancel();

            // Force clock-out in Firestore IF currently clocked in locally
            if (isClockedIn.value) { // Check local state before calling
              await _forceClockOutInFirestore(user.uid); // MUST await this
            }

            // Proceed with sign out (no await needed for UI update)
            signOut();

            Get.snackbar(
              'Session Expired',
              'You have been logged in on another device.',
              snackPosition: SnackPosition.BOTTOM,
              backgroundColor: Colors.orange,
              colorText: Colors.white,
            );
            isUserDataLoading.value = false; // Ensure loading state is updated
            return; // IMPORTANT: Stop processing this outdated document
          }
          // --- End Security Check ---

          // Update user name
          userName.value = data['name'] ?? user.email ?? 'Staff Member';

          // Handle clock-in status and background tracking
          bool wasClockedIn = isClockedIn.value;
          // Check both fields for safety, preferring isClockedIn
          bool isNowClockedIn = data['isClockedIn'] ?? data['isCheckedIn'] ?? false;
          isClockedIn.value = isNowClockedIn; // Update local state

          if (wasClockedIn != isNowClockedIn) {
            if (isNowClockedIn) {
              _startTracking();
            } else {
              _stopTracking();
            }
          }
        } else {
          // User document doesn't exist (maybe deleted?)
          print("User document does not exist for uid: ${user.uid}");
          _userDocSubscription?.cancel(); // Stop listening
          // Decide if you want to sign out the user automatically here
          // signOut();
          isUserDataLoading.value = false;
          return; // Stop processing
        }

        // Initialize activity listener only ONCE
        if (!hasInitializedActivityListener) {
          _listenToActivityLogs();
          hasInitializedActivityListener = true;
        }
        isUserDataLoading.value = false; // Mark loading complete on success

      }, onError: (error) {
        // Handle errors fetching user data
        print("Error listening to user data: $error");
        isUserDataLoading.value = false; // Mark loading complete on error
        Get.snackbar(
          'Database Error',
          'Could not sync user status. Please check connection.',
          snackPosition: SnackPosition.BOTTOM,
          backgroundColor: Colors.red,
          colorText: Colors.white,
        );
      });
    } else {
      // User is not logged in
      isUserDataLoading.value = false;
    }
  }

  // --- Set Date Filter ---
  void setFilter(String newFilter) {
    if (dateFilter.value == newFilter) return;
    dateFilter.value = newFilter;
    _listenToActivityLogs(); // Re-fetch logs with the new filter (if applicable)
  }

  // --- Listen to Activity Logs ---
  void _listenToActivityLogs() {
    _activityStreamSubscription?.cancel(); // Cancel previous listener
    final user = _auth.currentUser;
    if (user == null) return;

    // Query for recent activity logs, ordered by server timestamp
    Query query = _firestore
        .collection('users')
        .doc(user.uid)
        .collection('activity_logs')
        .orderBy('timestamp', descending: true)
        .limit(50); // Limit results for performance

    _activityStreamSubscription = query.snapshots().listen((snapshot) {
      List<ActivityLog> newLogs = snapshot.docs.map((doc) {
        final log = ActivityLog.fromFirestore(doc);
        // Fetch address asynchronously for each log
        _fetchAddressForLog(log);
        return log;
      }).toList();

      activityLogs.value = newLogs;

      // Update last activity time display
      if (activityLogs.isNotEmpty && activityLogs.first.timestamp != null) {
        try {
          lastActivityTime.value =
              DateFormat('hh:mm a').format(activityLogs.first.timestamp!.toDate());
        } catch (e) {
          print("Error formatting last activity timestamp: ${activityLogs.first.timestamp}");
          lastActivityTime.value = 'Error';
        }
      } else {
        lastActivityTime.value = 'N/A';
      }
    }, onError: (error){
      print("Error listening to activity logs: $error");
      // Optionally show an error to the user
    });
  }

  // --- Fetch Address for a Single Log ---
  Future<void> _fetchAddressForLog(ActivityLog log) async {
    // Prevent fetching if already fetched or if location is invalid
    if (log.address.value != 'Loading address...' || log.location == null) return;

    try {
      List<geocoding.Placemark> placemarks =
      await geocoding.placemarkFromCoordinates(
          log.location!.latitude, log.location!.longitude);
      if (placemarks.isNotEmpty) {
        final place = placemarks.first;
        // Construct a concise address string
        log.address.value =
        "${place.street ?? ''}${place.street != null && place.locality != null ? ', ' : ''}${place.locality ?? ''}";
        if (log.address.value.isEmpty) {
          log.address.value = "Address details not found.";
        }
      } else {
        log.address.value = "Address not found.";
      }
    } catch (e) {
      print("Error fetching address for log: $e");
      // Handle specific errors like network error
      if (e.toString().contains('kCLErrorDomain Code=2')) {
        log.address.value = "Network error getting address.";
      } else {
        log.address.value = "Could not get address.";
      }
    }
  }

  // --- Get Initial Location and Address ---
  Future<void> _getCurrentLocationAndAddress() async {
    currentAddress.value = 'Getting location...';
    // DO NOT set currentLatLng.value = null; here - causes map reload
    isLocationError.value = false; // Reset error state

    try {
      LocationData? locationData = await _getCurrentLocation();
      if (locationData != null &&
          locationData.latitude != null &&
          locationData.longitude != null) {

        currentLatLng.value =
            LatLng(locationData.latitude!, locationData.longitude!);
        _updateMapLocation(); // Update map view

        // Fetch address
        try {
          List<geocoding.Placemark> placemarks =
          await geocoding.placemarkFromCoordinates(
              locationData.latitude!, locationData.longitude!);
          if (placemarks.isNotEmpty) {
            final place = placemarks.first;
            currentAddress.value =
            "${place.street ?? ''}${place.street != null && place.locality != null ? ', ' : ''}${place.locality ?? ''}, ${place.country ?? ''}";
            if (currentAddress.value.trim() == ',') { // Handle empty parts
              currentAddress.value = "Address details not found.";
            }
          } else {
            currentAddress.value = "Address not found.";
          }
        } catch (e) {
          print("Error getting address in _getCurrentLocationAndAddress: $e");
          currentAddress.value = "Could not get address.";
          // Consider setting location error true if address is crucial here
          // isLocationError.value = true;
        }
        isLocationError.value = false; // Location fetch successful

      } else {
        // Location fetch failed (permission denied, service off, etc.)
        currentAddress.value = "Location not available.";
        // Do NOT set currentLatLng to null, keep the last known value if any
        isLocationError.value = true;
      }
    } catch (e) {
      // Exception during location fetch
      print("Error in _getCurrentLocationAndAddress: $e");
      currentAddress.value = "Could not get location.";
      // Do NOT set currentLatLng to null
      isLocationError.value = true;
    }
  }

  // --- Toggle Clock-In/Out Status (Corrected) ---
  Future<void> toggleClockInStatus() async {
    isLoading.value = true;
    final user = _auth.currentUser;
    if (user == null) {
      Get.snackbar('Error', 'You are not logged in.');
      isLoading.value = false;
      return;
    }

    try {
      final newStatus = !isClockedIn.value;
      LocationData? locationData = await _getCurrentLocation();

      if (locationData == null) {
        Get.snackbar('Location Error',
            'Could not get location. Please enable GPS and try again.');
        isLocationError.value = true; // Set error state if location fails
        isLoading.value = false;
        return;
      }
      // If location succeeds, reset error state
      isLocationError.value = false;

      // --- Update user's main doc ---
      await _firestore.collection('users').doc(user.uid).set({
        'isClockedIn': newStatus,
        'currentLocation':
        GeoPoint(locationData.latitude!, locationData.longitude!),
        'lastSeen': FieldValue.serverTimestamp(),
      }, SetOptions(merge: true));

      // --- Add to activity subcollection ---
      await _firestore
          .collection('users')
          .doc(user.uid)
          .collection('activity_logs')
          .add({
        'status': newStatus ? 'clocked-in' : 'clocked-out',
        'timestamp': FieldValue.serverTimestamp(), // *** USE SERVER TIME ***
        'location':
        GeoPoint(locationData.latitude!, locationData.longitude!),
      });

      // --- Update UI Directly (No _getCurrentLocationAndAddress call) ---
      currentLatLng.value =
          LatLng(locationData.latitude!, locationData.longitude!);
      // Update address text
      try {
        List<geocoding.Placemark> placemarks =
        await geocoding.placemarkFromCoordinates(
            locationData.latitude!, locationData.longitude!);
        if (placemarks.isNotEmpty) {
          final place = placemarks.first;
          currentAddress.value =
          "${place.street ?? ''}${place.street != null && place.locality != null ? ', ' : ''}${place.locality ?? ''}, ${place.country ?? ''}";
          if (currentAddress.value.trim() == ',') {
            currentAddress.value = "Address details not found.";
          }
        } else {
          currentAddress.value = "Address not found.";
        }
      } catch (e) {
        print("Error getting address after toggle: $e");
        if (e.toString().contains('kCLErrorDomain Code=2')) {
          currentAddress.value = "Network error getting address.";
        } else {
          currentAddress.value = "Could not update address.";
        }
      }
      // Update map view (includes null check for mapController)
      _updateMapLocation();
      // --- End Direct Update ---


      Get.snackbar(
        'Success',
        'You have successfully ${newStatus ? "clocked in" : "clocked out"}.',
        snackPosition: SnackPosition.BOTTOM,
        backgroundColor: Colors.green,
        colorText: Colors.white,
      );
    } catch (e) {
      Get.snackbar('Error', 'An error occurred: ${e.toString()}',
          snackPosition: SnackPosition.BOTTOM,
          backgroundColor: Colors.red,
          colorText: Colors.white);
    } finally {
      isLoading.value = false;
    }
  }

  // --- Get Current Location (with mock check & permission handling) ---
  Future<LocationData?> _getCurrentLocation() async {
    Location location = Location();
    bool serviceEnabled;
    PermissionStatus permissionGranted;

    // Check if location service is enabled
    serviceEnabled = await location.serviceEnabled();
    if (!serviceEnabled) {
      serviceEnabled = await location.requestService();
      if (!serviceEnabled) {
        Get.snackbar('GPS Error', 'Please enable location services.', snackPosition: SnackPosition.BOTTOM);
        return null; // Service not enabled
      }
    }

    // Check location permission status
    permissionGranted = await location.hasPermission();
    if (permissionGranted == PermissionStatus.denied) {
      permissionGranted = await location.requestPermission();
      if (permissionGranted != PermissionStatus.granted) {
        Get.snackbar('Permission Error', 'Location permission denied.', snackPosition: SnackPosition.BOTTOM);
        return null; // User denied the request
      }
    } else if (permissionGranted == PermissionStatus.deniedForever) {
      debugPrint("Location permission permanently denied.");
      Get.snackbar(
        'Permission Error',
        'Location permission is permanently denied. Please go to app settings to enable it.',
        snackPosition: SnackPosition.BOTTOM,
        backgroundColor: Colors.red,
        colorText: Colors.white,
        duration: const Duration(seconds: 5), // Longer duration for settings message
      );
      return null; // Permanently denied
    }

    // Get location if service and permissions are okay
    try {
      final locationData =
      await location.getLocation().timeout(const Duration(seconds: 30));

      // Mock location check
      if (locationData.isMock == true) {
        debugPrint("Mock location detected. Rejecting.");
        Get.snackbar(
          'Error',
          'Fake GPS is not allowed. Please disable mock locations.',
          snackPosition: SnackPosition.BOTTOM,
          backgroundColor: Colors.red,
          colorText: Colors.white,
        );
        return null; // Reject mock location
      }
      return locationData;

    } on TimeoutException {
      debugPrint("Location request timed out.");
      Get.snackbar(
        'Location Error',
        'Could not get location: Request timed out.',
        snackPosition: SnackPosition.BOTTOM,
        backgroundColor: Colors.orange,
        colorText: Colors.white,
      );
      return null;
    } catch (e) {
      debugPrint("Error getting location: $e");
      Get.snackbar(
        'Location Error',
        'An unknown error occurred while getting location.',
        snackPosition: SnackPosition.BOTTOM,
        backgroundColor: Colors.red,
        colorText: Colors.white,
      );
      return null;
    }
  }

  // --- Sign Out (with force clock-out) ---
  Future<void> signOut() async {
    final user = _auth.currentUser;
    final wasClockedIn = isClockedIn.value;

    _stopTracking(); // Stop background fetch first

    // Ensure Firestore reflects clock-out if user was clocked in
    if (user != null && wasClockedIn) {
      await _forceClockOutInFirestore(user.uid);
    }

    await _auth.signOut();
    // Optional: Clear local token on manual sign out if desired
    // await _deviceStorage.remove('fcmToken');
    Get.offAllNamed(Routes.LOGIN); // Navigate to login screen
  }

  // --- Force Clock-Out in Firestore (for single-device logout) ---
  Future<void> _forceClockOutInFirestore(String userId) async {
    print("Forcing clock-out in Firestore for user: $userId");
    try {
      // Attempt to get current location for the log entry
      LocationData? locationData = await _getCurrentLocation();
      GeoPoint? lastLocation = (locationData != null && locationData.latitude != null && locationData.longitude != null)
          ? GeoPoint(locationData.latitude!, locationData.longitude!)
          : null; // Use null if location fails or is incomplete

      // Update the main user document to clocked out state
      await _firestore.collection('users').doc(userId).update({
        'isClockedIn': false,
        // Update isCheckedIn as well if you use it interchangeably
        'isCheckedIn': false,
        // Optionally update last known location and seen time
        // 'currentLocation': lastLocation ?? FieldValue.delete(), // Or delete if null
        // 'lastSeen': FieldValue.serverTimestamp(),
      });

      // Add the automatic clock-out activity log
      await _firestore
          .collection('users')
          .doc(userId)
          .collection('activity_logs')
          .add({
        'status': 'clocked-out', // Ensure consistent status naming
        'timestamp': FieldValue.serverTimestamp(), // Secure server time
        'location': lastLocation, // Can be null
        'reason': 'auto_sign_out_new_device' // Indicate why this happened
      });
      print("Forced clock-out successful in Firestore.");
    } catch (e) {
      print("Error during forced clock-out in Firestore: $e");
      // Log this error, as it might leave the user state inconsistent
    }
  }
}

// lib/app/modules/home/home_view.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart'; // <-- Map import
import 'package:intl/intl.dart';
import '../../models/activity_log_model.dart';
import 'home_controller.dart';

class HomeView extends GetView<HomeController> {
  const HomeView({super.key});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Staff Dashboard'),
        actions: [
          IconButton(
            icon: const Icon(Icons.logout),
            tooltip: 'Sign Out',
            onPressed: () => controller.signOut(),
          ),
        ],
      ),
      body: RefreshIndicator(
          onRefresh: controller.onPullToRefresh,
        child: SingleChildScrollView(
          physics: const AlwaysScrollableScrollPhysics(),
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [

                Obx(() => controller.isUserDataLoading.value
                    ? _buildLoadingIndicator()
                    : _buildWelcomeCard(theme)),
                const SizedBox(height: 20),
                _buildMapView(), // <-- Google Map
                const SizedBox(height: 20),
                _buildClockInOutButton(),
                const SizedBox(height: 24),
                _buildActivityHeader(theme),
                const SizedBox(height: 8),
                _buildRecentActivityList(theme),
              ],
            ),
          ),
        ),
      ),
    );
  }

  // --- Live updating clock ---
  Widget _buildCurrentTimeCard(ThemeData theme) {
    return Card(
      elevation: 2,
      color: theme.colorScheme.primaryContainer,
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 12.0),
        child: Obx(() => Center(
          child: Text(
            controller.currentTime.value,
            style: theme.textTheme.titleMedium?.copyWith(
              color: theme.colorScheme.onPrimaryContainer,
              fontWeight: FontWeight.bold,
            ),
          ),
        )),
      ),
    );
  }

  // --- Google Map View ---
  Widget _buildMapView() {
    return Obx(() {
      if (controller.currentLatLng.value == null) {
        return Card(
          elevation: 2,
          child: SizedBox(
            height: 250,
            child: Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  const CircularProgressIndicator(),
                  const SizedBox(height: 16),
                  Text(controller.currentAddress.value),
                ],
              ),
            ),
          ),
        );
      }
      return Card(
        elevation: 2,
        clipBehavior: Clip.antiAlias,
        child: SizedBox(
          height: 250,
          child: GoogleMap(
            onMapCreated: controller.onMapCreated,
            initialCameraPosition: CameraPosition(
              target: controller.currentLatLng.value!,
              zoom: 16.0,
            ),
            markers: controller.markers.value,
            myLocationEnabled: false,
            myLocationButtonEnabled: false,
            zoomControlsEnabled: true,
          ),
        ),
      );
    });
  }

  Widget _buildLoadingIndicator() {
    return const Card(
      child: SizedBox(
        height: 180,
        child: Center(
          child: CircularProgressIndicator(),
        ),
      ),
    );
  }

  Widget _buildWelcomeCard(ThemeData theme) {
    return Card(
      elevation: 2,
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Obx(() => Text(
              'Welcome, ${controller.userName.value}',
              style: theme.textTheme.headlineSmall?.copyWith(
                color: theme.colorScheme.primary,
                fontWeight: FontWeight.bold,
              ),
            )),
            const SizedBox(height: 16),
            _buildInfoRow(
              theme,
              icon: Icons.location_on_outlined,
              label: 'Location:',
              valueWidget: Obx(() => Text(
                controller.currentAddress.value,
                style: theme.textTheme.bodyLarge,
                overflow: TextOverflow.ellipsis,
                maxLines: 1,
              )),
            ),
            const SizedBox(height: 8),
            // --- THIS IS THE WIDGET YOU ASKED ABOUT ---
            // It is correct and will update automatically.
            Obx(
                  () => _buildInfoRow(
                theme,
                icon: controller.isClockedIn.value
                    ? Icons.check_circle_outline
                    : Icons.cancel_outlined,
                iconColor:
                controller.isClockedIn.value ? Colors.green : Colors.amber,
                label: 'Current Status:',
                valueText:
                controller.isClockedIn.value ? 'Clocked In' : 'Clocked Out',
              ),
            ),
            // --- END OF WIDGET ---
            const SizedBox(height: 8),
            Obx(
                  () => _buildInfoRow(
                theme,
                icon: Icons.access_time_outlined,
                label: 'Last Activity:',
                valueText: controller.lastActivityTime.value,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildInfoRow(ThemeData theme,
      {required IconData icon,
        required String label,
        String? valueText,
        Widget? valueWidget,
        Color? iconColor}) {
    return Row(
      children: [
        Icon(icon, color: iconColor ?? theme.colorScheme.secondary, size: 20),
        const SizedBox(width: 12),
        Text('$label ',
            style: theme.textTheme.bodyLarge
                ?.copyWith(fontWeight: FontWeight.bold)),
        Expanded(
          child: valueWidget ??
              Text(
                valueText ?? '',
                style: theme.textTheme.bodyLarge,
              ),
        ),
      ],
    );
  }

  Widget _buildClockInOutButton() {
    return Obx(
          () {
        // Determine if the button should be disabled
        // It's disabled if loading, if location hasn't loaded yet (currentLatLng is null),
        // or if there was an error getting the location.
        final bool isDisabled = controller.isLoading.value ||
            controller.currentLatLng.value == null ||
            controller.isLocationError.value;

        // Determine the button text based on the state
        String buttonText;
        if (controller.currentLatLng.value == null || controller.isLocationError.value) {
          buttonText = 'Getting Location...'; // Show this while waiting for location or if error
        } else if (controller.isClockedIn.value) {
          buttonText = 'Clock Out';
        } else {
          buttonText = 'Clock In';
        }

        return ElevatedButton.icon(
          style: ElevatedButton.styleFrom(
            backgroundColor: isDisabled
                ? Colors.grey // Grey color when disabled
                : (controller.isClockedIn.value
                ? Colors.orange.shade700
                : Colors.green.shade600), // Active colors
            padding: const EdgeInsets.symmetric(vertical: 16),
            textStyle: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
          ),

          // --- THE KEY PART: onPressed is null when isDisabled is true ---
          onPressed: isDisabled ? null : () => controller.toggleClockInStatus(),

          icon: controller.isLoading.value
              ? Container( // Show loading spinner if isLoading is true
            width: 24,
            height: 24,
            padding: const EdgeInsets.all(2.0),
            child: const CircularProgressIndicator(
              color: Colors.white,
              strokeWidth: 3,
            ),
          )
              : Icon(controller.isClockedIn.value ? Icons.logout : Icons.login), // Show appropriate icon

          // --- Use the determined button text ---
          label: Text(buttonText),
        );
      },
    );
  }

  Widget _buildActivityHeader(ThemeData theme) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Text(
          'Recent Activity',
          style: theme.textTheme.titleLarge,
        ),
        Obx(() => PopupMenuButton<String>(
          onSelected: (value) => controller.setFilter(value),
          itemBuilder: (BuildContext context) => <PopupMenuEntry<String>>[
            const PopupMenuItem<String>(
              value: 'Last 7 Days',
              child: Text('Last 7 Days'),
            ),
            const PopupMenuItem<String>(
              value: 'All Time',
              child: Text('All Time'),
            ),
          ],
          child: Row(
            children: [
              Text(
                controller.dateFilter.value,
                style: theme.textTheme.bodyLarge
                    ?.copyWith(color: theme.colorScheme.secondary),
              ),
              Icon(Icons.arrow_drop_down,
                  color: theme.colorScheme.secondary),
            ],
          ),
        )),
      ],
    );
  }

  Widget _buildRecentActivityList(ThemeData theme) {
    return Obx(() {
      if (controller.activityLogs.isEmpty) {
        return Center(
          child: Padding(
            padding: const EdgeInsets.symmetric(vertical: 24.0),
            child: Text(
              'No activity found for "${controller.dateFilter.value}".',
            ),
          ),
        );
      }
      return ListView.builder(
        shrinkWrap: true,
        physics: const NeverScrollableScrollPhysics(),
        itemCount: controller.activityLogs.length,
        itemBuilder: (context, index) {
          final ActivityLog log = controller.activityLogs[index];
          final isClockIn = log.status == 'clocked-in';
          final formattedTime =
          DateFormat('EEE, MMM d, hh:mm a').format(log.timestamp.toDate());

          return Card(
            margin: const EdgeInsets.symmetric(vertical: 4),
            child: ListTile(
              leading: Icon(
                isClockIn ? Icons.login : Icons.logout,
                color: isClockIn ? Colors.green : Colors.orange,
              ),
              title: Text(isClockIn ? 'Clocked In' : 'Clocked Out'),
              subtitle: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(formattedTime),
                  const SizedBox(height: 4),
                  Obx(
                        () => Row(
                      children: [
                        Icon(Icons.location_on,
                            size: 14,
                            color: theme.textTheme.bodySmall?.color),
                        const SizedBox(width: 4),
                        Expanded(
                          child: Text(
                            log.address.value,
                            style: theme.textTheme.bodySmall,
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ),
          );
        },
      );
    });
  }
}

// lib/app/modules/splash/splash_controller.dart
import 'package:firebase_auth/firebase_auth.dart';
import 'package:get/get.dart';
import '../../routes/app_pages.dart';

class SplashController extends GetxController {
  @override
  void onInit() {
    super.onInit();
    _checkUserStatus();
  }

  void _checkUserStatus() {
    // Using a stream to listen to auth state changes ensures we handle all cases
    FirebaseAuth.instance.authStateChanges().listen((User? user) {
      if (user == null) {
        // User is not logged in, go to login page
        Get.offAllNamed(Routes.LOGIN);
      } else {
        // User is logged in, go to home page
        Get.offAllNamed(Routes.HOME);
      }
    });
  }
}

for splash modules it doesn't have some thing special so I just sent you controller 

// lib/app/routes/app_pages.dart
import 'package:get/get.dart';

import '../modules/auth/auth_binding.dart';
import '../modules/auth/login_view.dart';
import '../modules/home/home_binding.dart';
import '../modules/home/home_view.dart';
import '../modules/splash/splash_binding.dart';
import '../modules/splash/splash_view.dart';
part 'app_routes.dart';

class AppPages {
  static const INITIAL = Routes.SPLASH;

  static final routes = [
    GetPage(
      name: Routes.SPLASH,
      page: () => const SplashView(),
      binding: SplashBinding(),
    ),
    GetPage(
      name: Routes.LOGIN,
      page: () => LoginView(),
      binding: AuthBinding(),
    ),
    GetPage(
      name: Routes.HOME,
      page: () => HomeView(),
      binding: HomeBinding(),
    ),
  ];

}

// lib/app/routes/app_routes.dart
part of 'app_pages.dart';

abstract class Routes {
  Routes._();
  static const HOME = _Paths.HOME;
  static const LOGIN = _Paths.LOGIN;
  static const SPLASH = _Paths.SPLASH;
}

abstract class _Paths {
  _Paths._();
  static const HOME = '/home';
  static const LOGIN = '/login';
  static const SPLASH = '/splash';
}
